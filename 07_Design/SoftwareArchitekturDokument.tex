\documentclass[11pt]{scrartcl}

\title{Software Architektur: JBomberman}
\author{Silvan Adrian \\ Fabian Binna \\ Pascal Kistler}
\date{\today{}}

\usepackage[ngerman]{babel}
\usepackage[automark]{scrpage2}
\usepackage{hyperref}
\usepackage{color}
\usepackage[normalem]{ulem}
\usepackage{scrpage2}
\usepackage{graphicx}
\usepackage{tabularx}
\graphicspath{ {./images/} }
\pagestyle{scrheadings}

\clearscrheadfoot
\ihead{\includegraphics[scale=0.4]{jbomberman}}
\ohead{Projekt: JBomberman}
\ifoot{Software Architektur: JBomberman}
\cfoot{Version: 1.06}
\ofoot{Datum: 01.04.15}
\setheadsepline{0.5pt}
\setfootsepline{0.5pt}

\usepackage{ucs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}


\begin{document}
\def\arraystretch{1.5}
\begin{titlepage}
\begin{center}
\vspace{10em}
\includegraphics[scale=2]{jbomberman}
\vspace{10em}
\end{center}
\begin{center}
\huge {Projekt: JBomberman} \\
\huge {Software Architektur}
\end{center}
\begin{center}
\vspace{10em}
\LARGE {Pascal Kistler} \\
\LARGE {Silvan Adrian} \\
\LARGE {Fabian Binna}
\end{center}

\end{titlepage}

\newpage
\section{Änderungshistorie}
\label{sec:Änderungen}

\begin{tabularx}{\linewidth}{l l l l}
\textbf{Datum} & \textbf{Version} & \textbf{Änderung}  & \textbf{Autor} \\
\hline
\textbf{01.04.15} & 1.00 & Erstellung des Dokuments & Gruppe \\
\textbf{04.04.15} & 1.01 & Logische Architektur & Fabian Binna \\
\textbf{05.04.15} & 1.02 & Logische Architektur Client & Fabian Binna\\
\textbf{05.04.15} & 1.03 & Ziele und Einschränkungen & Silvan Adrian\\
\textbf{06.04.15} & 1.04 & Logische Architektur Server & Fabian Binna\\
\textbf{06.04.15} & 1.05 & Zustandsdiagramm Workflows & Fabian Binna\\
\textbf{06.04.15} & 1.06 & Systemübersicht Grafik und Beschreibung & Silvan Adrian\\
\end{tabularx}

\newpage
\tableofcontents
\newpage

\section{Einführung}
\subsection{Zweck}
Dieses Dokument beschreibt die Software Architektur für das Projekt JBomberman.
\subsection{Gültigkeitsbereich}
Dieses Dokument ist während des ganzen Projekts gültig und wird laufend aktualisiert.
\subsection{Referenzen}
<Liste aller verwendeten und referenzierten Dokumente, Bücher, Links, usw.>
<Referenz auf ein Glossar Dokument, wo alle Abkürzungen und unklaren Begriffe erklärt werden>
<Die Quellen / Referenzen sollten mit dem Word Tool automatisch erstellt werden>
\subsection{Übersicht}
<Übersicht über den restlichen Teil dieses Dokumentes geben und dessen Aufbau erläutern>
 
\section{Systemübersicht}
JBomberman kann nur als Mehrspielerspiel gespielt werden, daher wird immer ein verfügbarer Server benötigt + muss ein RabbitMQ Server verfügbar sein.
Zudem braucht es mindestens 2 Clients, damit ein Spiel überhaupt gespielt werden kann.
Zur Veranschaulichung der Austausch zwischen 2 Clients und 1 Server:

\includegraphics[scale=0.45]{systemuebersicht}

 
\section{Architektonische Ziele \& Einschränkungen}
\subsection{Ziele}
\begin{itemize}
    \item Die Spielumgebungen müssen mit allen Clients synchronisiert werden (über den dedizierten Server)
    \item Möglichkeit weitere PowerUp's einzubauen.
    \item Austausch zwischen den Clients und dem Server wird über JMS umgesetzt.
\end{itemize}


\subsection{Einschränkungen}
\begin{itemize}
    \item Es wird keinen Live Server geben, jeder der das Spiel spielen will muss einen eigenen Server starten.
    \item Die Clients können nur zum Server Verbindung aufnehmen, wenn diese die IP des Servers kennen.
\end{itemize}


\newpage
 
\section{Logische Architektur: Applikationsübergreifend}
Dieses Package Diagramm zeigt sowol Client, als auch Server. Client und Server sind zwei eigenständige Applikationen, die getrennt ausgeführt werden. Sie verwenden jedoch teilweise die gleichen Packages.

\includegraphics[scale=0.5]{LogischeSicht}

\newpage

\subsection{Time/time}
Im Package time sind Klasse, die für das timing der GameLoops sorgen.
\subsubsection{Klassenstruktur}
\includegraphics[scale=0.8]{ClassDiagramTime}

\textbf{Timer}\\
Der Timer besitzt eine Referenz auf einen GameLoop, bei dem er regelmässig die Methode loop() aufruft.

\newpage

\subsection{Domain/game}
Im Package game befinden sich Klassen und Interfaces, die von Server und Client gemensam genutzt werden.
\subsubsection{Klassenstruktur}
\includegraphics[scale=0.75]{ClassDiagramGame}
\newpage
\textbf{Action}\\
Die Action Klasse wird über das Netzwerk zwischen Server und Client versendet und enthält Statusnachrichten, sowie Aktualisierungsdaten für die Objekte.\\

\textbf{ActionQueue}\\
Die ActionQueue speichert die Actions. Die Actions werden bei jedem loop aus der Queue entfernt und verarbeitet. Die ActionQueue muss Threadsafe sein, da der ActionDispatcher die Queue füllt.\\

\textbf{ActionDispatcher}\\
Der ActionDispatcher ist ein Thread und ist ausschliesslich damit beschäftig auf eingehende Messages zu warten und diese als Action in der Queue einzureihen.\\

\textbf{Player}\\
Der Player speichert die Daten eines Spielers. Die Daten werden für die Zuweisung von Actions und das Darstellen des Scoreboard benötigt.\\

\textbf{Party}\\
Die Party beinhaltet alle Player eines Spiels. Ein Spiel kann nur mittels einer Party instanziert werden.

\newpage

\subsection{Utilities/utils}
Im Package utils befinden sich Hilfsklassen.
\subsubsection{Klassenstruktur}
\includegraphics[scale=0.75]{ClassDiagramUtils}

\textbf{ImageManager}\\
Der ImageManager lädt die Bilder. Jedes Sprite holt sich von da die Bilddaten.\\

\textbf{ActionSerializer}\\
Die Methoden des ActionSerializer sind statisch und werden benötigt um die Actions für das Netzwerk zu serialisieren bzw. deserialisieren.\\

\newpage

\section{Logische Architektur: Client}
\subsection{Presentation/view}
Im Package view befinden sich Frames und Canvas, die für die Presentation des Clients notwendig sind.


\subsubsection{Klassenstruktur}
\includegraphics[scale=0.8]{ClassDiagramView}


\textbf{GameFrame}\\
Der GameFrame ist ein Observer und delegiert die Notifies an das zugehörige Panel, die sich dann selber auf den neusten Stand bringen.\\

\textbf{GameCanvas}\\
Der GameCanvas kümmert sich nur um das Rendering, also das Zeichnen der Szene. Dabei delegiert er jedoch nur die pixels[] an alle Sprites, welche sich dann eigenständig zeichnen. Der GameCanvas kümmert sich dann um das performante Buffering.\\\\
\begin{tabularx}{\linewidth}{l p{12cm}}
\textbf{Methode} & \textbf{Beschreibung}\\
\hline
render():void & Kümmert sich um die BufferStrategy und delegiert das zeichnen der Sprites direkt an die Sprites selbst.
\end{tabularx}

\newpage

\subsection{Workflow/application.client}
Im Package application.client befindet sich der workflow des Clients. Er kontrolliert wann der PartyFrame und der GameFrame sichtbar ist.

\subsubsection{Klassenstruktur}
\includegraphics[scale=0.75]{ClassDiagramApplicationClient}

\textbf{ClientController}\\
Der ClientController kontrolliert den Zustand der Client-Applikation. Er notifiziert nur den PartyFrame, nicht aber den GameFrame.\\
\begin{table}[!h]
\begin{tabularx}{\linewidth}{l X}
\textbf{Methode} & \textbf{Beschreibung}\\
\hline
startGame():void & Erstellt eine GameFrame, welches die ClientGame Klasse instanziert und somit das Spiel startet.\\
finishGame():void & Informiert den PartyFrame darüber, dass das Spiel beendet wurde.\\
addPlayer(player: Player) : void & Fügt einen neuen Player in die Party ein.\\
removePlayer(player: Player) : void & Entfernt einen Player aus der Party.\\
connectToServer(hostname: String) : void & Verbindet den Client mit einem RabbitMQ Broker.\\
disconnect() : void & Schliesst die Verbindung mit dem RabbitMQ Broker.\\
setReady(b: Boolean): void & Setzt den Spieler auf bereit.\\

\end{tabularx}
\end{table}


\newpage
\subsection{Domain/game.client}
Im Package game.client werden die Actions vom Server interpretiert und die Sprites auf den neusten Stand gebracht. Die Sprites werden in einer Layer-Logik gespeichet, damit sie korrekt gezeichnet werden können.

\subsubsection{Klassenstruktur}
\includegraphics[scale=0.5]{ClassDiagramGameClient}

\textbf{ClientGame}\\
Die Methode loop wird unter "Wichtige interne Abläufe" beschrieben.\\

\textbf{SpriteManager}\\
Der SpriteManager speicher alle Sprites in einer Schichten-Logik. Dies wird benötig, damit die Sprites korrekt gezeichnet werden können. Zudem können die Sprites per id gefunden werden, damit das aktualisieren der Positionen und Zustände einfacher wird. Die Methoden des SpriteManager sind ähnlich wie bei normalen Datenstrukturen und werden deshalb nicht weiter erläutert.

\newpage

\textbf{Sprite}\\
Die Sprite-Klasse beinhaltet alle Informationen die für das Zeichnen der Spielobjekte benötig wird.\\
\begin{table}
\begin{tabularx}{\linewidth}{l X}
\textbf{Methode} & \textbf{Beschreibung}\\
\hline
update(action : Acton) : void & Interpretiert die Action und führt die nötigen Aktualisierungsschritte durch.\\
draw(screen : int[]) : void & Zeichnet sich selbst auf den screen. Diese Methode wird vom GameCanvas aufgerufen und liefert seinen screen mit auf dem gezeichnet werden kann.\\
tick() : void & Aktualisiert das Sprite. Wird hauptsächlich für Animationen benötigt.\\
\end{tabularx}\\
\end{table}
\textbf{Keyboard}\\
Das Keyboard zeichnet die Tastatureingaben auf und sendet diese direkt über die Methode update an den Server.

\subsubsection{Wichtige interne Abläufe}
//SSD zur GameLoop realisiertung einfügen.


\newpage

\subsection{Network/network.client}

Der Client und der Server implementieren beide das Interface NetworkFacade. Die implementation ist jedoch grundverschieden.

\subsubsection{Klassenstruktur}
\includegraphics[scale=0.5]{ClassDiagramNetworkClient}

\textbf{ClientNetwork}\\
Die Klasse ClientNetwork implementiert die NetworkFacade.\\

\textbf{ClientSender}\\
Der Client Sender sendet direkt auf eine RabbtiMQ-Queue. Alle Clients senden auf die selbe Queue.\\

\textbf{ClientReceiver}\\
Der ClientReceiver holt Messages aus seiner eigenen RabbitMQ-Queue. Der Server sendet seine Updates auf jede einzelne Queue.

\newpage

\subsection{Wichtige Abläufe}
\subsubsection{Zustandsdiagramm Client Workflow}
\includegraphics[scale=0.5]{StatemachineClient}

\newpage

\section{Logische Architektur: Server}

\subsection{Workflow/application.server}

Der Workflow des Servers ist sehr simpel. Er wartet bis mehr als zwei Spieler verbunden und bereit sind, und startet dann das Spiel.

\subsubsection{Klassenstruktur}
\includegraphics[scale=0.75]{ClassDiagramApplicationServer}

\begin{tabularx}{\linewidth}{l p{9cm}}
\textbf{Methode} & \textbf{Beschreibung}\\
\hline
wairForPlayers() : void & Der Server befindet sich nach dem Starten in dieser Methode und wartet bis mehr als ein Spieler verbunden und bereit ist. Danach startet er das Spiel.\\
startGame(party : Party) : void & Erstellt die nötigen Klassen und startet das Spiel.\\
finishGame() : void & Entkoppelt die Spielrelevanten Klassen und geht in die waitForPlayers Methode zurück.\\
\end{tabularx}

\newpage

\subsection{Domain/game.server}

\subsubsection{Klassenstruktur}
\includegraphics[scale=0.5]{ClassDiagramGameServer}

\textbf{ServerGame}\\
Die Methode loop() wird unter "wichtige Abläufe" genauer beschrieben.\\

\textbf{GameObjectManager}\\
Der GameObjectManager speichert die GameObject nach Typen ab. Dies ist hilfreich, wenn die Objekte aktualisiert werden müssen. Die Methoden des GameObjectManagers sind ähnlich wie bei normalen Datenstrukturen und werden deshalb nicht weiter erläutert.\\

\newpage

\textbf{GameObject}\\
Das GameObject speichert alle nötigen Informationen um das Spielgeschehen und die Interaktionen der Gameobjects zu berechnen.\\


\begin{tabularx}{\linewidth}{l p{6cm}}
\textbf{Methode} & \textbf{Beschreibung}\\
\hline
tick() : void & Aktualisiert Zustände und Variablen. Hauptsächlich Zeitbedingte Werte (Wann kann ich die nächste Bombe legen)\\
update(action : Action) : void & Interpretiert die Action und aktualisiert sich selbst.\\
sendUpdates() : void & Falls das Object neue Werte besitzt muss es die neuen Daten an die Clients senden.\\
checkCollisionWidth(o : GameObject) : Boolean & Überprüft, ob das Object mit einem anderen kollidiert und führt dann die jeweiligen Korrekturen (z.B. beim Movement) oder Aktionen durch.\\

\end{tabularx}

\newpage

\subsection{Network/network.server}

Der Client und der Server implementieren beide das Interface NetworkFacade. Die implementation ist jedoch grundverschieden.

\subsubsection{Klassenstruktur}
\includegraphics[scale=0.5]{ClassDiagramNetworkServer}

\textbf{ServerNetwork}\\
Die Klasse ServerNetwork implementiert die NetworkFacade.\\

\textbf{ServerSender}\\
Der ServerSender sendet alle Daten die im übergeben werden direkt an alle angemeldeten Clients.\\

\textbf{ServerReceiver}\\
Der ServerReceiver holt alle Daten aus einer einzelnen RabbitMQ-Queue, auf welche alle Clients senden.\\

\newpage

\subsection{Wichtige Abläufe}
\subsubsection{Zustandsdiagramm Server Workflow}
\includegraphics[scale=0.7]{StatemachineServer}













 
\section{Prozesse und Threads}
<Wenn mehrere Prozesse oder Threads eingesetzt werden wird hier beschrieben, wie diese ablaufen, miteinander funktionieren, Daten austauschen, sich synchronisieren, usw.>
 
\section{Deployment}
<Beschreibung der einzelnen Komponenten und deren Aufteilung (auf welchen Umgebungen, Servern, usw. laufen die Komponenten)>
 
\section{Grössen und Leistung}
<Einschränkungen der Applikation bezüglich Speicher, Leistung, etc…. (zum Beispiel: Verwaltung unterstützt maximal 20'000 Einträge)>


\end{document}